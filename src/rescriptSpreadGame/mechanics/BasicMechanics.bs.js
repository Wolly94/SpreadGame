// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Vector2D from "../common/Vector2D.bs.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Direction2D from "../common/Direction2D.bs.js";
import * as CommonMechanics from "./CommonMechanics.bs.js";

function bubbleCollision(b1, b2) {
  var dist = Vector2D.distance(b1.position, b2.position);
  return dist <= Math.min(b1.radius, b2.radius);
}

function cellCollision(b1, c) {
  var dist = Vector2D.distance(b1.position, c.position);
  return dist <= Math.min(b1.radius, c.radius);
}

function collideBubble(b1, b2) {
  return [
          Caml_option.some(b1),
          Caml_option.some(b2)
        ];
}

function collideCell(bubble, cell) {
  return [
          Caml_option.some(bubble),
          cell
        ];
}

function grow(cell, timeInMs) {
  var capacity = CommonMechanics.radiusToUnits(cell.radius);
  var unitInc = CommonMechanics.radiusToGrowthPerSecond(cell.radius) * timeInMs / 1000;
  var newUnits = capacity >= cell.units ? Math.min(capacity, cell.units + unitInc) : Math.max(capacity, cell.units - unitInc);
  return {
          id: cell.id,
          ownerId: cell.ownerId,
          units: newUnits,
          radius: cell.radius,
          position: cell.position
        };
}

function move(bubble, timeInMs) {
  var travelDist = CommonMechanics.defaultBubbleSpeedInPixelPerSecond * timeInMs / 1000;
  var positionInc = Vector2D.scalarMul(Direction2D.toVector(bubble.direction), travelDist);
  var newPosition = Vector2D.add(bubble.position, positionInc);
  return {
          id: bubble.id,
          ownerId: bubble.ownerId,
          units: bubble.units,
          radius: bubble.radius,
          position: newPosition,
          direction: bubble.direction,
          targetCellId: bubble.targetCellId,
          targetCellPosition: bubble.targetCellPosition
        };
}

export {
  bubbleCollision ,
  cellCollision ,
  collideBubble ,
  collideCell ,
  grow ,
  move ,
  
}
/* No side effect */
