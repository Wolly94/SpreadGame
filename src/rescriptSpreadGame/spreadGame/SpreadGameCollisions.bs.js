// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as ArrayMethods from "../helperFunctions/ArrayMethods.bs.js";

function SpreadGameCollisions(Mechs) {
  var getCollision = function (bubbles, cells) {
    var bubbleCollision = ArrayMethods.findAndMapi((function (b1, index) {
            var ob2 = bubbles.slice(0, index).find(function (b2) {
                  return Curry._2(Mechs.bubbleCollision, b1, b2);
                });
            return Belt_Option.map(ob2 === undefined ? undefined : Caml_option.some(ob2), (function (b2) {
                          return {
                                  TAG: /* BeforeBubbleCollision */1,
                                  _0: {
                                    bubble: b1,
                                    other: b2
                                  }
                                };
                        }));
          }), bubbles);
    if (Belt_Option.isSome(bubbleCollision)) {
      return bubbleCollision;
    } else {
      return ArrayMethods.findAndMap((function (bubble) {
                    var oc = cells.find(function (cell) {
                          return Curry._2(Mechs.cellCollision, bubble, cell);
                        });
                    return Belt_Option.map(oc === undefined ? undefined : Caml_option.some(oc), (function (cell) {
                                  return {
                                          TAG: /* BeforeCellCollision */0,
                                          _0: {
                                            bubble: bubble,
                                            other: cell
                                          }
                                        };
                                }));
                  }), bubbles);
    }
  };
  var collideBubbles = function (bubbles) {
    var collisionEvents = [];
    var newBubbles = bubbles.reduce((function (survivors, bubbleToAdd) {
            var match = survivors.reduce((function (param, newSurvivor) {
                    var newCurrentBubble = param[1];
                    var prevSurvivors = param[0];
                    if (newCurrentBubble === undefined) {
                      return [
                              [newSurvivor].concat(prevSurvivors),
                              newCurrentBubble
                            ];
                    }
                    if (!Curry._2(Mechs.bubbleCollision, newSurvivor, newCurrentBubble)) {
                      return [
                              [newSurvivor].concat(prevSurvivors),
                              newCurrentBubble
                            ];
                    }
                    var match = Curry._2(Mechs.collideBubble, newCurrentBubble, newSurvivor);
                    var newRemBubble = match[1];
                    var newCurrBubble = match[0];
                    var collisionEvent_0 = {
                      bubble: newCurrentBubble,
                      other: newSurvivor
                    };
                    var collisionEvent_1 = {
                      bubble: newCurrBubble,
                      other: newRemBubble
                    };
                    var collisionEvent = {
                      TAG: /* BubbleCollision */0,
                      _0: collisionEvent_0,
                      _1: collisionEvent_1
                    };
                    collisionEvents.push(collisionEvent);
                    if (newRemBubble !== undefined) {
                      return [
                              [newRemBubble].concat(prevSurvivors),
                              newCurrBubble
                            ];
                    } else {
                      return [
                              prevSurvivors,
                              newCurrBubble
                            ];
                    }
                  }), [
                  [],
                  bubbleToAdd
                ]);
            var currentBubble = match[1];
            var newSurvivors = match[0];
            if (currentBubble !== undefined) {
              return [currentBubble].concat(newSurvivors);
            } else {
              return newSurvivors;
            }
          }), []);
    return [
            newBubbles,
            collisionEvents
          ];
  };
  var collideCells = function (bubbles, cells) {
    var collisionEvents = [];
    var match = bubbles.reduce((function (param, newBubble) {
            var remainingBubbles = param[0];
            var match = param[1].reduce((function (param, cell) {
                    var processedCells = param[1];
                    var currentBubble = param[0];
                    if (currentBubble === undefined) {
                      return [
                              undefined,
                              Belt_Array.concat(processedCells, [cell])
                            ];
                    }
                    if (!Curry._2(Mechs.cellCollision, currentBubble, cell)) {
                      return [
                              currentBubble,
                              Belt_Array.concat(processedCells, [cell])
                            ];
                    }
                    var match = Curry._2(Mechs.collideCell, currentBubble, cell);
                    var newB = match[0];
                    var collisionEvent_0 = {
                      bubble: currentBubble,
                      other: cell
                    };
                    var collisionEvent_1 = {
                      bubble: newB,
                      other: cell
                    };
                    var collisionEvent = {
                      TAG: /* CellCollision */1,
                      _0: collisionEvent_0,
                      _1: collisionEvent_1
                    };
                    collisionEvents.push(collisionEvent);
                    return [
                            newB,
                            Belt_Array.concat(processedCells, [match[1]])
                          ];
                  }), [
                  newBubble,
                  []
                ]);
            var futureCells = match[1];
            var remBubble = match[0];
            if (remBubble !== undefined) {
              return [
                      Belt_Array.concat(remainingBubbles, [remBubble]),
                      futureCells
                    ];
            } else {
              return [
                      remainingBubbles,
                      futureCells
                    ];
            }
          }), [
          [],
          cells
        ]);
    return [
            match[0],
            match[1],
            collisionEvents
          ];
  };
  return {
          getCollision: getCollision,
          collideBubbles: collideBubbles,
          collideCells: collideCells
        };
}

export {
  SpreadGameCollisions ,
  
}
/* No side effect */
